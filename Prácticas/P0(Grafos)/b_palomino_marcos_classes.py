# -*- coding: utf-8 -*-
"""B_Palomino_Marcos_Classes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fBkvcJj3dQ8gCv7uOcmN3pgvIfh_iTq-

<div style="padding:30px; color: white; background-color: #0071CD">
<center>
<img src="img/logoub.jpeg"></img>
<center>
<p>
<h1>Algorítmica Avanzada</h1>
<h2>Práctica 0 - Introducción a clases python para grafos</h2>
</center>
</p>
</div>

<h2>Aviso general de Prácticas y Problemas.</h2>

Es de suma importancia <b>comentar todo vuestro código</b>. Comentar el código no solo facilita a otras personas que lo lean la compresión del mismo, si no también a vosotros mismos durante el proceso de diseño e implementación, así como al regresar tras tiempo sin ver el código. Además, a la hora de ser corregidos, un código comentado se entiende mejor, lo cual ayuda a trasladar al profesor las ideas que teníais al tratar de implementarlo (más aún en el caso de que no lo hayáis podido terminar con éxito). No es necesario comentar cada línea, pero si lo que hace cada parte del código.

En segundo lugar, es <b>imperativo <font size=3.5 color="#FF0000">☠☠☠ respetar las cabeceras de las funciones y estructura del return ☠☠☠</font></b> que se indiquen en el enunciado. Pese a que leemos y corregimos vuestros códigos en detalle, empleamos correctores automáticos para guiar y agilizar el proceso. De esta manera, si se pide que la función tenga la siguiente estructura:

<code>def funcion_ejercicio(lista1, indice1):
    ... # implementación de la solución
    return elemento_resultado </code>
    
En el notebook deberá existir una y solo una función con el nombre <i>funcion_ejercicio</i> que reciba exactamente los parámetros indicados y devuelva las variables en el formato y con el tipo que se requiera en el eunciado. En todos los enunciados se explicitará qué tipo de datos han de pasarse a las funciones y devolverse. <b> La no adherencia al formato de las funciones <font size=3.5 color="#FF0000">☠☠☠ conllevará a una puntuación nula sobre ese ejercicio. ☠☠☠</font> </b>

Ambas aptitudes son fundamentales a la hora de desarrollar código en el mundo laboral. En muchas ocasiones trabajaréis con código de otras personas: tener por costumbre estas buenas prácticas facilita mucho compartir código, emplear otras librerías y permite a la comunidad crecer de manera limpia y efectiva.

Por último, durante el curso trabajaremos con Python 3.6. Mientras que muchas de las cosas que explicaremos aplican a cualquier versión de Python,  determinados comportamientos del lenguaje sólo serán compatibles con Python 3.6. Asimismo, las tareas requeridas deberán implementarse siempre en dicha versión.
"""

# Comprueba tu versión de python
import sys
sys.version

"""## Recordando conceptos básicos... (Python 3.6)
En Python disponemos de los siguientes tipos básicos:
"""

# Numeros enteros (o 'int')
my_int = 42
# Numero sdecimales (o 'float')
my_float = 3.14
# Cadenas de caracteres (o 'String')
my_string = "towel"
# Booleanos
my_bool = True # Los valores booleanos en python son con mayuscula (True/False y no true/false)

"""Las tres estructuras básicas de Python son __listas__, __tuplas__ y __diccionarios__. Admiten ser rellenadas con cualquier tipo de dato."""

my_list = [1, 2, "watermelon", ["whatever"]]     # las listas se definen empleando corchetes []
my_tuple = (1, 2, 3, "watermelon", ["whatever"]) # las tuplas se definen empleando paréntesis ()
my_dict = {"key1": 1, "key2": [1,2,3]}           # los diccionarios se definen con llaves {}

"""Recordad que, aunque podemos recorrerlos igual empleando un bucle <i>for</i>, los iteradores y las listas no son lo mismo."""

# al solicitar las claves de un diccionario obtenemos un iterador, no una lista
print(my_dict.keys()) 
# de la misma manera, la funcion "range" nos devuelve un iterador, no una lista
print(range(10))     
# la funcion "list" convierte un iterador en una lista
print(list(my_dict.keys()))  
# una manera equivalente de convertir un iterador en una lista es empleando list comprehension
print([x for x in my_dict.keys()]) 
# equivalente a la linea anterior (podemos iterar directamente sobre el diccionario)
print([x for x in my_dict])

"""Los accesos a todas estas estructuras se realizan mediante el uso de corchetes [ ]. Las tuplas, cadenas y listas pueden ser accedidas por índice (lo cual nos devolverá un elemento concreto) o usando slice (que nos devuelve un subconjunto de la estructura)."""

print(my_list[2])        # Devuelve un elemento concreto
print(my_string[-2])     # En python podemos indexar en orden inverso empleando 
print(my_tuple[1:3])     # Devuelve los elementos del 1 al 3 (sin incluir este ultimo)
print(my_list[:-1])      # Si el primer elemento se omite, se asume 0
print(my_string[::-1])   # Usar ::-1 invierte el orden de la estructura

"""Por otro lado, los diccionarios se acceden empleando una clave concreta"""

my_dict["key2"]

"""Y hay que recordar que las tuplas y los strings no son mutables! Es decir, una vez hayamos definido su valor no se pueden cambiar. Al ejecutar la siguiente línea debería dar error. Recordad que los mensajes de error de Python nos aportan parte de la información necesaria para entender la causa del fallo: nos indica en qué línea de la celda (o del archivo .py si fuera el caso) ha saltado el fallo y, a continuación, nos describe el error concreto que hemos tenido. Cuando estéis programando recordad que Google es vuestro amigo. En este caso nos muestra que hay un fallo en la línea 1 de la celda y nos indica que posiblemente se deba a que las tuplas no permiten reasignar valores a sus elementos."""

my_tuple[2] = "two" # al tratar de ejecutar esto obtendremos un error

"""Mientras que las listas y los diccionarios sí que lo son."""

mylist[2] = "abc"
mydict["key3"] = "cba"
print(mylist)
print(mydict)

"""También hay que recordar que los objetos y estructuras de Python se relacionan por referencia, es decir, al pasarlos a funciones o meterlos en otras estructuras no estamos "copiando" el objeto, si no pasando una referencia a este. Por otra parte, las variables tipo básicas de python si que se copian."""

# Observad que no es necesario retornar la lista para que el cambio sea efectivo fuera de la funcion
def add_element(l,e):
    l.append(e)     
    
def sum_one(x):
    x += 1
    return x

a = [1,2,3,4]
b = ["element1",a,"element2"]
c = 3
my_dict2 = {"key1": a, "key2": b, "key3": c}

# Podemos modificar la variable "a" desde dentro de la funcion.
# Ademas el cambio se refleja tambien en el diccionario que contiene una referencia a la variable "a"
print("my_dict2 before\t",my_dict2)
add_element(a,5)
print("my_dict2 after\t",my_dict2)

# Podemos modificar la variable "a" desde "b" ya que "b" contiene una referencia a "a", y no una copia de la misma. 
print("\na before \t",a)
b[1][2] = 25
print("a after \t",a)

# De la misma manera podemos modificar "b" desde el diccionario "my_dict2"
print("\nb before \t",b)
my_dict2["key2"].append("element3")
print("b after \t",b)

# Las variables basicas si que se copian al ser pasadas a una funcion
#  de manera que no se ven afectadas por cambios dentro de la funcion
print("\nc before\t",c)
sum_one(c)
my_dict2["key3"] += 25 # Si mostramos ahora my_dict2["key3"] podremos ver que es 28, mientras "c" no cambia
print("c after \t",c)

# Para cambiar el valor de "c" tendremos que reasignarlo
c = sum_one(c)
print("c after2\t",c)

"""Por último recordar una de las características más fuertes de Python, lo que se denomina list comprehension y nos permite generar listas dinámicamente y en una sola línea de código"""

alist = [x for x in range(1,11)] # Numeros hasta el 10
print(alist)
blist = [x for x in alist if not x % 2] # Numeros pares
print(blist)
clist = [x**2 for x in blist] # Potencias de los pares
print(clist)
# Tambien lo podemos usar para construir diccionarios
adict = {x: [] for x in blist}
print(adict)
bdict = {x: [y for y in range (x, 10)] for x in blist}
print(bdict)

"""Hasta este punto hemos estado refrescando elementos y funcionamiento de Python que ya deberíais conocer del año pasado. Si sentís vuestros conocimientos de Python algo oxidados o si algo de lo explicado arriba no os suena, podéis repasar con <a href="https://learnxinyminutes.com/docs/python/">esta guía rápida de Python</a> que también os puede servir para consultar rápidamente las estructuras básicas cuando programéis. La guía extiende sobre los conocimientos que esperamos que tengáis en este punto del curso, pero deberíais estar familiarizados con los primeros 3 puntos y os deberían sonar muchas cosas del 4 y el 5.

A continuación os dejamos con un par de problemas sencillos para ir calentando motores:

<div class="alert alert-success">
<h1>Problema 1</h1>
<p><strong>
Implementa una función, utilizando list comprehension, que dada una variable entera $limit$ y una variable entera $mult$ te devuelva una lista con todos los multiplos de $mult$ en el rango $limit$.
<br><br>Ejemplos:<br>
<i>myfunc(10, 2) -> [2,4,6,8,10] <br>
myfunc1(15,3) -> [3, 6, 9, 12, 15]<br>
myfunc1(20,4) -> [4, 8, 12, 16, 20]<br>
myfunc1(5,3) -> [3]</i>
</strong></p>
</div>
"""

def myfunc1(limit,mult):
    # Reemplaza la siguiente linea por tu solucion
    out_list = [x * mult for x in range(1,limit) if limit >= (x * mult)]
    return out_list

# Prueba tu algoritmo
print(myfunc1(10,2))
print(myfunc1(15,3))
print(myfunc1(20,4))
print(myfunc1(5,3))

"""<div class="alert alert-success">
<h1>Problema 2</h1>
<p><strong>
Implementa una función, utilizando list comprehension, que dada tres variables enteras: $limit$, $mult$ y $exc$ te devuelva una lista con todos los multiplos de $mult$ en el rango $limit$ excepto los que sean también múltiplos de $exc$.
<br><br>
Ejemplos:<br> 
<i>myfunc(10, 2, 4) -> [2,6,10]<br>
myfunc2(20,3,9) -> [3, 6, 12, 15]<br>
myfunc2(28,4,3) -> [4, 8, 16, 20, 28]<br>
myfunc2(14,2,3) -> [2, 4, 8, 10, 14]</i>
</strong></p>
</div>
"""

def myfunc2(limit, mult, exc):
    # Reemplaza la siguiente linea por tu solucion
    out_list = [x * mult for x in range(1,limit) if limit >= (x * mult) and (x * mult) % exc != 0]
    return out_list

print(myfunc2(10,2,4))
print(myfunc2(20,3,9))
print(myfunc2(28,4,3))
print(myfunc2(14,2,3))

"""# Object Oriented Programming

<div class="alert alert-danger" style="margin:0 auto;">
<center><p><h3> DISCLAIMER: PYTHON IS NOT JAVA! </h3></p></center> 

Es importante mencionar una serie de convenciones y buenas prácticas que se siguen al realizar Programación Orientada a Objetos en Python:
<ul>
<li><b>Underscore notation</b>: En Python se utiliza <i>underscore notation</i> para definir variables y métodos y <i>CamelCase notation</i> para las clases; es decir 
<ul>
    <li><i>MyClass</i></li>
    <li><i>my_method</i></li>
    <li><i>my_var</i> </li>
    </ul></li>
<li><b>Scope</b>: En Python todas las variables son públicas, no existe el concepto <i>protected</i> y <i>private</i>. En las buenas prácticas se recomienda que las variables que se suponen privadas lleven un '_' previo al nombre de la variable, es decir: 
<ul>
<li>_private_var</li>
<li>public_var</li>
</ul>
Análogamente, en los métodos privados se recomienda que el método empieze y acabe con _ 
<ul>
<li>_my_private_method_()</li>
<li><italic>my_public_method()</italic></li></ul>
</div>

Veamos ahora como se crea una clase en Python. En el siguiente ejemplo vemos un objeto simple con el constructor `__init__` y un método `__str__` que tiene el mismo comportamiento que el `toString()` de Java. Estos métodos son conocidos como <i>underscore methods</i> y se emplean para definir funcionalidades estándar del lenguaje Python para la clase que estamos definiendo. Podéis consultar una lista extendida de estos métodos <a href="http://www.siafoo.net/article/57"> aquí</a>. La clase incluye, además, un método personalizado que nos permitirá incrementar la edad de las personas representadas en nuestra clase.

Es importante ver cómo siempre que referenciamos un atributo nos referimos a él precedido por `self`. Esto determina que la variable se declara y trabaja a nivel de clase. Todas las funciones que se definan dentro de una clase tendrán `self` como primer parámetro. Este es un parámetro "transparente" que se instanciará de manera automática al llamar a los métodos de la clase sobre un objeto específico.
"""

"""
Esta clase guarda un nombre propio y la edad asociada
"""
class Klass:
    # Constructor
    def __init__(self, name, age):
        # Los atributos de la clase se incluyen siempre bajo el 'self'
        # equivalente al 'this' en Java. No es necesario declararlos todos en el constructor
        # siempre que garanticemos que el orden de ejecución pasará siempre por
        # la declaración de la variable antes de cualquier uso que se haga de la misma.
        self.name = name
        self.age = age
    
    # incrementa la edad
    def increase_age(self):
        self.age += 1
    
    # toString
    def __str__(self):
        return "Name of subject is: " + self.name + "\t Age of subject is: " + str(self.age)
    
    # compara dos objetos de tipo Klass
    def __eq__(self,other): # __lt__ <  __sum__ +  __gt__
        return self.name == other.name and self.age == other.age
    
    # Definimos la "suma" de dos objetos de nuestra clase como la concatenación de sus nombres
    #  y la suma de sus edades.
    def __add__(self,other):
        return Klass(self.name+' '+other.name,self.age+other.age)

# Cuando creamos un nuevo objeto de una clase, estamos llamando al constructor
klass_instance = Klass("John", 42) 
# Tipo de la variable "klass_instance"
print(type(klass_instance))

# Al pasarle un objeto a la función "print", esta busca el método __str__ para convertirlo antes de imprimir
print(klass_instance) 
# Por lo cual es equivalente a estas dos líneas
print(str(klass_instance))
print(klass_instance.__str__())

# No es necesario pasarle nada, el parametro "self" de esta funcion
# se instancia automaticamente al objeto de la clase Klass contenido en la variable klass_instance
klass_instance.increase_age()

print(klass_instance)

# Finalmente recordad que siempre podemos acceder a las variables internas de un objeto directamente
klass_instance.age = 12

print(klass_instance)

# Podemos comparar dos objetos de la misma clase gracias al metodo __eq__
klass_instance2 = Klass("Mary",56)
print(klass_instance == klass_instance2)
print(klass_instance == klass_instance)

# Podemos sumar dos instancias de la misma clase gracias al metodo __add__
print(klass_instance + klass_instance2)

"""Una particularidad de los objetos en Python es que podemos definir un método que se comporte como un atributo utilizando el decorador `@property`. Esto es muy útil ya que nos permite crear máscaras para los valores internos y nos permite que la representación de los atributos sea más clara.

Es una buena práctica utilizar este método para dar visibilidad a los atributos desde el exterior, en lugar de poner a la vista la representación interna. Mediante este método podemos controlar los accesos que se hacen al objeto.
"""

class Klass:
    def __init__(self):
        self._value = {1:"aa", 21:"bb", 31:"cc"}
        
    @property
    def val(self):
        return self._value
    
kls = Klass()
kls.val[1] # Equivalente a kls._value[1], pero mas sencillo

"""De esta forma, Python nos ofrece una forma de crear correctamente los Setters y Getters de una propiedad del objeto."""

class PositiveValues:
    def __init__(self):
        self._value = 0
        
    @property
    def val(self):
        return self._value
    
    # Mientras indiquemos que es un setter de una 
    # property concreta podemos ponerle cualquier nombre
    @val.setter
    def random_name(self, value):
        if value > 0:
            self._value = value
        
pv = PositiveValues()
print(pv.val)
pv.random_name = 8 # Equivalente a pv._value = 8
print(pv.val)
pv.random_name = -3 # Si hicieramos pv._value = -3 estariamos permitiendo un valor negativo
print(pv.val)

"""<div class="alert alert-info">
<center>
  <h1>Grafos</h1>
</center>
</div>

Como ya os ha sido introducido en clase de teoría, un grafo es un conjunto de objetos llamados vértices o nodos unidos por enlaces llamados aristas o arcos, que permiten representar relaciones entre elementos de un conjunto.

Típicamente, un grafo se representa gráficamente como un conjunto de puntos (vértices o nodos) unidos por líneas (aristas).

Desde un punto de vista práctico, los grafos permiten estudiar las interrelaciones entre unidades que interactúan unas con otras. Por ejemplo, una red de computadoras puede representarse y estudiarse mediante un grafo, en el cual los vértices representan terminales y las aristas representan conexiones (las cuales, a su vez, pueden ser cables o conexiones inalámbricas). 

_(from Wikipedia)_

![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/6n-graf-clique.svg/220px-6n-graf-clique.svg.png "Graph")

En esta introducción a los grafos pretendemos diseñar nuestra propia librería de programación de grafos. Esta librería contendrá la clase **Graph** que tendremos que programar siguiendo unas pautas marcadas en el enunciado de la práctica.

Durante todo el curso, representaremos nuestros grafos mediante <b>listas de adyacencia</b>. No obstante, para poder incluir atributos tanto en los nodos como en las aristas, la estructura de python que emplearemos serán los <b>diccionarios</b>. Los <b>nodos</b> podrían ser cualquier tipo de variable que pudiera ser empleada como clave de un diccionario (enteros, strings, floats, tuplas...) no obastante, nosotros trabajaremos siempre con <b>números enteros</b>. En el grafo que aparece en la imagen de arriba, los nodos serían $[1,2,3,4,5,6]$.

Por otra parte, las <b>aristas</b> las representaremos como una tupla $(a,b)$ dónde $a$ y $b$ serán nodos y la tupla indica que el grafo contiene una arista que va del nodo $a$ al nodo $b$. En el grafo que aparece en la imagen de arriba, las aristas serían $[(1,2),(1,5),(2,3),(2,5),(3,4),(4,5),(4,6)]$. Para la clase grafo que construiremos que siempre trabaja con grafos no dirigidos, deberemos replicar nuestras aristas para permitir las relaciones en ambos sentidos. En otras palabras, para representar la arista $(a,b)$ necesitaremos también la arista inversa $(b,a)$.

En particular, mantendremos dos estructuras fundamentales. <br>
La primera será un <b>diccionario de nodos</b> cuyas claves serán números enteros que identifiquen al nodo y los valores serán diccionarios de atributos: <br>
<code>{node_id: 
    {attribute_name: attribute_value}
 }</code><br>
La segunda será un <b>diccionario de aristas</b>, cuyas claves serán números enteros que identifiquen al nodo origen de la arista y los valores serán a su vez diccionarios. Las claves de estos diccionarios serán números enteros que identifiquen al nodo destino de la arista y los valores serán diccionarios de atributos:<br>
<code>{node_start_id: 
    {node_end_id: 
         {attribute_name: attribute_value}
    }
 }</code><br>
 
 Por ejemplo, si quisiéramos crear un grafo de contagios del Covid19, donde los nodos fueran personas y las aristas representaran el contacto que han tenido entre ellas, podríamos tener un par de diccionarios como los siguientes:

<!-- Si actualizamos los atributos del nodo 1 con {'age':23, 'PCR':True}-->

<code>nodes = {1: {'name':'Jenny', 'PCR':False}, <!-- El resultado será {'name':'Jenny', 'PCR':True, 'age':23}-->
          2: {'name':'Karl','PCR':True},
          3: {'name':'Valery','PCR':True},
          4: {'name':'Will','PCR':False}},
edges = {1: {4: {'distance':2.1},
             3: {'distance': 0.5},
         2: {3: {'distance':0.6}},
         3: {1: {'distance': 0.5},
             2: {'distance': 0.6}},
         4: {1: {'distance':2.1}}}
</code>


Estos diccionarios estarían representando un grafo como este:
<img src="./img/covid_graph.png">


Fijaos que las aristas existen tanto en un sentido como en el otro y los atributos son los mismos para ambas. Además podemos ver que Jenny debería hacerse otra PCR.

<div class="alert alert-info">
<center>
  <h1>Contenido</h1>
  </center><p>
</div>

<div class="alert alert-success" style="width:90%; margin:0 auto;">
  <h2><p>1- Graph</p></h2>
  
  <p>
      Para representar un grafo necesitaremos vértices y aristas, ambos pueden contener atributos. Por ejemplo, debemos de poder añadir para un vértice $k$ el atributo $color$ y para una arista $(k,p)$ el atributo $longitud$. En este caso la arista $(k,p)$ es aquella que va del vértice $k$ al vértice $p$. Durante el curso, representaremos los grafos como diccionarios de nodos y diccionarios de aristas. Esta representación sería equivalente a la lista de adyacencia. Para la implementación de esta clase podría resultaros últil la <a href="https://docs.python.org/3/library/stdtypes.html#typesmapping">documentación de diccionarios de python</a>.
      <br>
      <ul> 
      <li><b>Graph.node</b>: (@property) Devuelve un diccionario {$key$, $value$} donde $key$ es un nodo y $value$ es el diccionario con los atributos del nodo.</li>
      <li><b>Graph.edge</b>: (@property) Devuelve un diccionario {$key$, $value$} donde $key$ es un nodo y $value$ es un diccionario {$key2$, $value2$} donde $key2$ es un nodo y $value2$ es el diccionario de atributos de la arista ($key$, $key2$).</li>
      <li><b>Graph.nodes()</b>: Devuelve una lista con todos los nodos [$node1$, $node2$, ..., $nodeN$].</li>
      <li><b>Graph.edges()</b>: Devuelve una lista con todas las aristas [($node1$, $node2$), ($node2$, $node3$), ..., ($nodeM$, $nodeN$)] representadas como tuplas. En esta representación no incluiremos las aristas opuestas, mostraremos sólo una tal que nodeM$<$nodeN.</li>
      <li><b>Graph.add_node($node$, $attr\_dict=None$)</b>: Añade un nodo al grafo, el parámetro opcional $attr\_dict$ nos permitirá darle características al nodo. Si el nodo $node$ ya existe, se actualizará el diccionario de características existente con $attr\_dict$*.</li>
      <li><b>Graph.add_edge($node1$, $node2$, $attr\_dict=None$)</b>: Añade una arista al grafo, el parámetro opcional $attr\_dict$ nos permitirá darle características a la arista. Si la arista ($node1, node2$) ya existe, se actualizará el diccionario de características existente con $attr\_dict$*. Si alguno de los dos nodos no existe, se creará de forma transparente con el diccionario atributos vacío.</li>
      <li><b>Graph.add_nodes($nodeList$, $attr\_dict=None$)</b>: Añade una lista de nodos al grafo y les asigna a todos las propiedades $attr\_dict$. Si alguno de los nodos ya existe se actualizarán sus caracteristicas con $attr\_dict$*.</li>
      <li><b>Graph.add_edges($edgeList$, $attr\_dict=None$)</b>: Añade una lista de aristas al grafo y les asigna a todos las propiedades $attr\_dict$. Si alguno de los vertices ya existe se actualizarán sus caracteristicas con $attr\_dict$*. Si alguno de los nodos no existe, se creará con el diccionario de atributos vacío.</li>
                  </ul>
      </p>
      * Es importante que tengáis cuidado al actualizar los diccionarios de atributos. Estaremos trabajando con dos diccionarios: el diccionario original y el nuevo que nos han pasado y que tenemos que emplear para actualizar el original. Si el original y el nuevo contienen ambos una clave común, el resultado será actualizar el valor de esa clave con el nuevo valor. Si el diccionario nuevo contiene una clave nueva, se añade con su valor al diccionario original. El resto de atributos del diccionario original no deberían cambiar.
      </div>
"""

# Sustituid la expresion "pass" por vuestras soluciones
class Graph:
    def __init__(self):
        # Inicializamos diccionarios de nodos y aristas
        self._nodes = dict()
        self._edges = dict()
    
    @property
    def node(self):
      return self._nodes

    @property
    def edge(self):
      return self._edges
    
    def nodes(self):
      # El metode list() de python, si per parametre li pasem un dictionari, retorna les seves keys
      return list(self._nodes)
    
    def edges(self):
      # Per convertir un dictionari en una llista de tuples, utilizarem list comprehension de python
      list = [(x,y) for x in self._edges for y in self._edges[x] if (x < y)]
      return list
    
    # Recordad que attr_dict es un parámetro opcional con un valor asignado por defecto (None)
    def add_node(self, node, attr_dict=None): 
      temp_dict = {}
      # Si el parametre attr_dict és None, retornarem un diccionari buit que guardem en la variable temp_dict ja que no volem 
      # que el valor sigui "None", perqué si ho és ens donará error en els asserts del test
      if attr_dict != None:
        temp_dict = attr_dict
      # Si el node ya es troba en el diccionari de nodes, l'actualitzem
      if node in self._nodes:
        self._nodes[node].update(temp_dict)       
      # Si no es troba, l'afegim
      else: 
        self._nodes[node] = temp_dict
        
    
    def add_edge(self, node1, node2, attr_dict=None):
      temp_dict = {}
      # Si el parametre attr_dict és None, retornarem un diccionari buit que guardem en la variable temp_dict ja que no volem 
      # que el valor sigui "None", perqué si ho és ens donará error en els asserts del test
      if attr_dict != None:
        temp_dict = attr_dict
      # Afegim els nodes en cas que no existeixin
      self.add_nodes_from([node1,node2], temp_dict)
      # Comprobem si els nodes es troben o no en el diccionari de edges, si es troben, utilitzarem el metode update per actualitzar la tupla key, values
      # per la del temp_dict (attr_dict), en cas que no els asignem al diccionari de edges
      if node1 or node2 not in self._edges:
        if node1 not in self._edges:
          self._edges[node1] = {node2: temp_dict}
        if node2 not in self._edges:
          self._edges[node2] = {node1: temp_dict}
      if node1 and node2 in self._edges:
          self._edges[node1].update({node2: temp_dict})


    
    def add_nodes_from(self, node_list, attr_dict=None):
      # Iterem sobre la llista de nodes, i cridem al nostre metode add_node per afegir els respectius nodes, en cas que ja existeixin, directament ho
      # gestionem en el metode add_node i no aqui.
      for i in range(len(node_list)):
        self.add_node(node_list[i],attr_dict)
    
    def add_edges_from(self, edge_list, attr_dict=None):
      # Iterem sobre la llista de edges, i cridem al nostre metode add_edge per afegir els respectius edges, en cas que ja existeixin, directament ho
      # gestionem en el metode add_edge i no aqui.
      for i in range(len(edge_list)):
        self.add_edge(edge_list[i][0],edge_list[i][1],attr_dict)

# Podéis probar vuestro código con esta celda. 
# La directiva "assert" en Python comprueba si una condición se cumple.
# En caso de que no se cumpla, parará la ejecución del programa y mostrará
#  un mensaje de error sobre la línea del assert que haya fallado.
# Podéis recurrir a hacer un print de la variable que se estaba comprobando en ese assert
#  en la línea inmediatamente anterior para poder comparar vosotros mismos el valor que se esperaba
#  y el que se ha obtenido con vuestro código para comprender mejor la raíz del problema.
# Una vez superéis todos los asserts el código debería ser correcto.
import sys
import traceback

# Graph.node, Graph.add_node(), Graph.nodes()
try:
    G = Graph()
    G.add_node(1)
    assert G.node == {1: {}}
    G.add_node(2, attr_dict={"position": 20})
    assert G.node == {1: {}, 2: {'position': 20}}
    assert G.node[2] == {'position': 20}
    assert G.nodes() == [1, 2]

    # Graph.edge, Graph.add_edge(), Graph.edges()
    G.add_edge(1,2, attr_dict={"size": 10})
    assert G.edge == {1: {2: {'size': 10}}, 2: {1: {'size': 10}}}
    assert G.edge[1][2] == {'size': 10}
    assert G.edge[2][1] == {'size': 10}
    G.add_edge(2,3)
    assert G.edges() == [(1, 2), (2, 3)]
    assert G.edge == {1: {2: {'size': 10}}, 2: {1: {'size': 10}, 3: {}}, 3: {2: {}}}

    # Graph.add_nodes(), Graph.add_edges()
    G = Graph()
    G.add_nodes_from([1,2])
    assert G.nodes() == [1, 2]
    G.add_nodes_from([2,3])
    assert G.nodes() == [1, 2, 3]
    G.add_nodes_from([3,4], attr_dict={"length":100})
    assert G.node == {1: {}, 2: {}, 3: {'length': 100}, 4: {'length': 100}}
    G = Graph()
    G.add_edges_from(((1,2), (2,3)), attr_dict={"width": 100})
    assert G.nodes() == [1,2,3]
    assert G.edges() == [(1, 2), (2, 3)]
    assert G.edge[1][2] == {'width': 100}
    print("All test passed!")
except AssertionError:
    _, _, tb = sys.exc_info()
    traceback.print_tb(tb) # Fixed format

"""<div class="alert alert-success" style="width:90%; margin:0 auto;">
  <h2><p>2- Graph</p></h2>
  
  <p>
      Ahora que ya tenemos los elementos principales vamos a añadir a nuestro grafo algunas funciones que nos ayudarán a desarrollar las siguientes prácticas:
      <br>
      <ul> 
          <li><b>Graph.degree($node$)</b>: Devuelve el grado del nodo $node$, es decir, el número de aristas que conectan con él.</li>
      <li><b>Graph.neighbors($node$)</b>: Devuelve una lista con los vecinos del nodo $node$, es decir, todos los nodos que están conectados a $node$ mediante una arista.</li>
      <li><b>Graph.__getitem__($node$)</b>: Devuelve un diccionario {$key$, $value$} donde $key$ son los nodos adyacentes a $node$ y $value$ el diccionario de atributos de la arista. Al implementar esta función podremos acceder a las aristas de un nodo concreto $n$ del grafo $G$ con el formato $G[n]$</li>
      <li><b>Graph.__len__()</b>: Retorna el numero de nodos que tiene el grafo. Al implementar esta función podremos acceder al tamaño de un grafo $G$ (en número de nodos) mediante la función de python $len(G)$. </li>
      <li><b>Graph.remove_edge($node1$, $node2$)</b>: Borra la arista del grafo (en ambos sentidos). </li>
      <li><b>Graph.remove_node($node$)</b>: Borra el vértice del grafo y todas las aristas que pasen a través de él.</li>
      <li><b>Graph.remove_edge_from($edgelist$)</b>: Borra una lista de aristas del grafo (cada una en sus dos sentidos). </li>
      <li><b>Graph.remove_node_from($nodelist$)</b>: Borra el la lista de vértices del grafo y todas las aristas que pasen a través de él.</li>
                  </ul>
      </p>
      </div>
"""

# Añadir los métodos del ejercicio 1
class Graph:


    def __init__(self):
        # Inicializamos diccionarios de nodos y aristas
        self._nodes = dict()
        self._edges = dict()
    
    @property
    def node(self):
      return self._nodes

    @property
    def edge(self):
      return self._edges
    
    def nodes(self):
      # El metode list() de python, si per parametre li pasem un diccionari, retorna les seves keys
      return list(self._nodes)
    
    def edges(self): 
      # Per convertir un dictionari en una llista de tuples, utilizarem list comprehension de python
      list = [(x,y) for x in self._edges for y in self._edges[x] if (x < y)]
      return list
    
    # Recordad que attr_dict es un parámetro opcional con un valor asignado por defecto (None)
    def add_node(self, node, attr_dict=None): 
      temp_dict = {}
      # Si el parametre attr_dict és None, retornarem un diccionari buit que guardem en la variable temp_dict ja que no volem 
      # que el valor sigui "None", perqué si ho és ens donará error en els asserts del test
      if attr_dict != None:
        temp_dict = attr_dict
      # Si el node ya es troba en el diccionari de nodes, l'actualitzem
      if node in self._nodes:
        self._nodes[node].update(temp_dict)       
      # Si no es troba, l'afegim
      else: 
        self._nodes[node] = temp_dict
        
    
    def add_edge(self, node1, node2, attr_dict=None):
      temp_dict = {}
      # Si el parametre attr_dict és None, retornarem un diccionari buit que guardem en la variable temp_dict ja que no volem 
      # que el valor sigui "None", perqué si ho és, ens donará error en els asserts del test
      if attr_dict != None:
        temp_dict = attr_dict
      # Afegim els nodes en cas que no existeixin
      self.add_nodes_from([node1,node2], temp_dict)
      # Comprobem si els nodes es troben o no en el diccionari de edges, si es troben, utilitzarem el metode update per actualitzar la tupla key, values
      # per la del temp_dict (attr_dict), en cas que no els asignem al diccionari de edges
      if node1 or node2 not in self._edges:
        if node1 not in self._edges:
          self._edges[node1] = {node2: temp_dict}
        if node2 not in self._edges:
          self._edges[node2] = {node1: temp_dict}
      if node1 and node2 in self._edges:
          self._edges[node1].update({node2: temp_dict})
          #self._edges[node2].update({node1: temp_dict})


    def add_nodes_from(self, node_list, attr_dict=None):
      # Iterem sobre la llista de nodes, i cridem al nostre metode add_node per afegir els respectius nodes, en cas que ja existeixin, directament ho
      # gestionem en el metode add_node i no aqui.
      for i in range(len(node_list)):
        pass
    

    def add_edges_from(self, edge_list, attr_dict=None):
      # Iterem sobre la llista de edges, i cridem al nostre metode add_edge per afegir els respectius edges, en cas que ja existeixin, directament ho
      # gestionem en el metode add_edge i no aqui.
      for i in range(len(edge_list)):
        self.add_edge(edge_list[i][0],edge_list[i][1],attr_dict)

    
    def degree(self, node):
      # Si el node no es troba conectat a cap edge, retornem 0
      if node not in self._edges:
        return 0
      # En cas contrari, retornem el nombre d'items (arestes), que es troben en el diccionari del node     
      else:
        return len(self._edges[node])
    

    def __getitem__(self, node):
      # Si el node no es troba conectat a cap edge, retornem un diccionari buit
      if node not in self._edges:
        return {}
      # Retorna els nodes adjacents a node, amb els seus atributs
      else:
        return self._edges[node]


    def __len__(self):
      # Retornem el nombre d'items (nodes), que es troben en el diccionari dels nodes
      return len(self._nodes)


    def neighbors(self, node):
      # Si el node no es troba en edges, retornem una llista buida
      if node not in self._edges:
        return []
      # En cas contrari, retornem una llista amb la key del node dins el diccionari d'edges
      else:
        return list(self._edges[node])
    

    def remove_node(self, node1):
      # Si el node no existeix, no fem res
      if node1 not in self._nodes:
        pass
      else:
        # Primer, comprobem que el node estigui conectat a uns altres nodes
        if len(self.neighbors(node1)) >= 1:
          for x in self._edges[node1]:
            # Eliminem les arestes que connectaven altres nodes amb node1
            del self._edges[x][node1]    
          # Eliminem el node del diccionari de edges
          del self._edges[node1]
        #Eliminem el node del diccionari de nodes
        del self._nodes[node1]
   
    def remove_edge(self, node1, node2):
      if node1 in self._edges:
        if node2 in self._edges[node1]:
          # Si el node2 es troba dins de les arestes que conecta node1, l'eliminem
          del self._edges[node1][node2]
          # Si despres de eliminar la aresta, ens queda un diccionari buit, l'eliminem
          if len(self._edges[node1]) == 0:
            del self._edges[node1]
      if node2 in self._edges:
        if node1 in self._edges[node2]:
          # Si el node1 es troba dins de les arestes que conecta node2, l'eliminem
          del self._edges[node2][node1]                   
          # Si despres de eliminar la aresta, ens queda un diccionari buit, l'eliminem
          if len(self._edges[node2]) == 0:
            del self._edges[node2]

    def remove_nodes_from(self, node_list):
      # Iterem sobre la llista que ens pasen, i cridem al metode remove_node
      for i in node_list:
        self.remove_node(i)
    
    def remove_edges_from(self, edge_list):
      # Iterem sobre la llista de arestes que ens pasen, cridem al metode remove_edge
      for i in range(len(edge_list)):
        self.remove_edge(edge_list[i][0], edge_list[i][1])

import sys
import traceback

try:
    G = Graph()
    G.add_edges_from(((1,2), (2,3), (2,4)))
    assert G.degree(2) == 3
    assert G.degree(1) == 1
    assert G[2] == {1: {}, 3: {}, 4: {}}
    print(len(G))
    assert len(G) == 4
    assert G.neighbors(1) == [2]
    assert G.neighbors(2) == [1,3,4]
    G.remove_node(1)
    assert G.node == {2: {}, 3: {}, 4: {}}
    assert G.edge == {2: {3: {}, 4: {}}, 3: {2: {}}, 4: {2: {}}}
    G.remove_edge(2,3)
    assert G.edge == {2: {4: {}}, 4: {2: {}}}
    assert G.node == {2: {}, 3: {}, 4: {}}
    assert G.neighbors(2) == [4]
    G.remove_edges_from(((2,4), (4,3)))
    assert G.edge == {}
    assert G.node == {2: {}, 3: {}, 4: {}}
    G.remove_nodes_from((2,3))
    assert G.edge == {}
    assert G.node == {4: {}}
    assert G.neighbors(4) == []
    assert len(G) == 1
    assert G.degree(4) == 0
    
    print("All test passed!")
except AssertionError:
    _, _, tb = sys.exc_info()
    traceback.print_tb(tb) # Fixed format

"""<div class="alert alert-info">
<center>
  <h1>Entrega</h1>
</center>
    
Para esta práctica sólo os pedimos que implementéis la clase grafos. Los otros dos problemas son opcionales, pero no os deberían resultar complicados.

<p>
La entrega se podrá realizar en el campus virtual hasta el día <b>11 de Octubre a las 23:55</b>. En la tarea que se habilitará en el campus deberéis colgar únicamente este notebook con el nombre:
</p>
<p>
    <code>[grupo]_[apellido]_[nombre]_Classes.ipynb</code>


</p>
<p>
    Por ejemplo, para un alumno llamado <i>Nombre Genérico Estándar</i> perteneciente al <i>grupo Z</i> de problemas el nombre del archivo debería ser:
</p>
<p>
<code>Z_Generico_Nombre_Classes.ipynb</code>
    <br>
Y <b>NO</b>:
<ul>
<li>Z00_Generico_Nombre_Classes.zip</li>
    
<li>ZX_Generico_Nombre_Classes.ipynb</li>

<li>Lab2_Generico_Nombre_Classes.rar</li>

<li>Classes.ipynb</li>
<li> ... literalmente cualquier otra cosa. </li>
</ul>
</p>
<p>


Es fundamental que el código esté bién comentado. La importancia de poner nombre correcto al archivo debería ser directamente proporcional a lo contentos que queráis que los profesores de prácticas corrijan.<b> <font size=3.5 color="#FF0000">☠☠☠ No adherirse al formato en el nombre del archivo así como entregar otro tipo de archivo o varios archivos, conllevará a la no corrección de vuestra práctica. ☠☠☠</font></b>
</p>
</div>
"""

